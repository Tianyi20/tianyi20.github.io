![image](https://github.com/user-attachments/assets/0922394d-d413-47f2-96e0-445bc316deee)---
title: 'tutorial of MOVEIT'
date: 2015-08-14
permalink: /posts/2024/11/blog-post-MOVEIT/
tags:
  - MOVEIT
  - MOVEIT
  - MOVEIT
---

Quick High Level Diagram:

![image](https://github.com/user-attachments/assets/ff3a830d-25c1-4632-b142-37fd978796bd)
![image](https://github.com/user-attachments/assets/9121a20d-5aee-44c9-8731-57623e90bf29)

 Configuration
move_group is a ROS node. It uses the ROS param server to get three kinds of information:

URDF - move_group looks for the robot_description parameter on the ROS param server to get the URDF for the robot.

SRDF - move_group looks for the robot_description_semantic parameter on the ROS param server to get the SRDF for the robot. The SRDF is typically created (once) by a user using the MoveIt Setup Assistant.

MoveIt configuration - move_group will look on the ROS param server for other configuration specific to MoveIt including joint limits, kinematics, motion planning, perception and other information. Config files for these components are automatically generated by the MoveIt setup assistant and stored in the config directory of the corresponding MoveIt config package for the robot.

## 我们开发一般都是用的moveit commander和rviz，下面给出moveit commander 的api PYTHON:

the API we always use is from: moveit movegroup, scene, robot. 因为我一般写python 代码，下面给出api，melodic版本：

1. 最常用的move_group: https://github.com/moveit/moveit/blob/melodic-devel/moveit_commander/src/moveit_commander/move_group.py

2. planning scene interface: [https://github.com/moveit/moveit/blob/melodic-devel/moveit_commander/src/moveit_commander/move_group.py](https://github.com/moveit/moveit/blob/melodic-devel/moveit_commander/src/moveit_commander/planning_scene_interface.py)

3. robot: 这个一般不常用，用来看move group，检查end effector是谁啊什么的：https://github.com/moveit/moveit/blob/melodic-devel/moveit_commander/src/moveit_commander/robot.py


##  Planning scene

planning scene其实就是通过外界的相机depth image或者Pointcloud image来自动生成 octomap，这个octomap会自动Publish 为move group scene monitoring 啥的消息，具体忘记了.

![image](https://github.com/user-attachments/assets/20b74a04-a605-4956-9151-693a39341454)

具体操作只需要给 yaml文件放上对应的需要订阅的消息就可以了，但是要注意这里的消息stamped的frame需要标定。
生成的octomap会自动处理掉机器人自己的点云，非常智能。
直接参考：https://moveit.github.io/moveit_tutorials/doc/perception_pipeline/perception_pipeline_tutorial.html

我的这个perception在仿真机器人可以跑，但是在我的实物机器人就跑不了，我也不知道什么原因。

Octomap
The Occupancy map monitor uses an Octomap to maintain the occupancy map of the environment. The Octomap can actually encode probabilistic information about individual cells although this information is not currently used in MoveIt. The Octomap can directly be passed into FCL, the collision checking library that MoveIt uses.

 Depth Image Occupancy Map Updater
The depth image occupancy map updater includes its own self-filter, i.e. it will remove visible parts of the robot from the depth map. It uses current information about the robot (the robot state) to carry out this operation.

##### 当然也可以自己创建一个scene，然后每次用的时候import进来就好了，但是注意这里的rviz有个惊天bug：
！！！！！！！！！！！！！

Launch RViz by running the rviz command in a new terminal.
Change Fixed Frame from map to base_link
Add RobotModel
Add MotionPlanning
**Scene Objects > Import from src/ur_robot_utils/config/chefbot_workspace_constraints.scene ** DO NOT CLICK PUBLISH BUTTON ** If click, have to redo whole rviz (Start from Step 1). You will see green boxes appear around the robot.** (这里千万不能点publish，点了就错要重头再来，逆天）

**Planning > change Planning Group from endeffector to manipulator (you should see arrows on end effector of robot)**(这里一定要点一下rviz 界面里的plan按钮，不点就不会真的import scene贼逆天)
Test by making it plan something by dragging the arrows (small change) and click Plan under Planning tab. Be sure to click YES for updating the Planning Scene. If you accidentally click No, restart from Step 1.


## 

Robot Interface
move_group talks to the robot through ROS topics and actions. It communicates with the robot to get current state information (positions of the joints, etc.), to get point clouds and other sensor data from the robot sensors and to talk to the controllers on the robot.

 Joint State Information 这个应该用的是 joint state publisher节点
 joint_state_publisher功能包为机器人发布sensor_msgs/JointState消息，该包从参数服务器读取robot_description参数，查找所有非固定关节，并发布定义了所有这些关节的JointState消息。
move_group listens on the /joint_states topic for determining the current state information - i.e. determining where each joint of the robot is. move_group is capable of listening to multiple publishers on this topic even if they are publishing only partial information about the robot state (e.g. separate publishers may be used for the arm and mobile base of a robot). Note that move_group will not setup its own joint state publisher - this is something that has to be implemented on each robot.
消息类型是这样的：
```
Header header

string[] name
float64[] position
float64[] velocity
float64[] effort
```

Transform Information 这个用的是 robot state publisher发布TF tree信息
move_group monitors transform information using the ROS TF library. This allows the node to get global information about the robot’s pose (among other things). E.g., the ROS navigation stack will publish the transform between the map frame and base frame of the robot to TF. move_group can use TF to figure out this transform for internal use. Note that move_group only listens to TF. To publish TF information from your robot, you will need to have a robot_state_publisher node running on your robot.
robot_state_publisher使用参数robot_description指定的URDF和joint_states (sensor_msgs/JointState)话题中的关节位置来计算机器人的正向运动学，并通过tf发布结果。

 Controller Interface
move_group talks to the controllers on the robot using the FollowJointTrajectoryAction interface. This is a ROS action interface. A server on the robot needs to service this action - this server is not provided by move_group itself. move_group will only instantiate a client to talk to this controller action server on your robot.
最后move_group发布给最底层机器人controller的消息是 /FollowJointTrajectoryAction，这是一个action interface，这个需要机器人厂家自身提供，

 Planning Scene
move_group uses the Planning Scene Monitor to maintain a planning scene, which is a representation of the world and the current state of the robot. The robot state can include any objects attached to (carried by) the robot which are considered to be rigidly attached to the robot. More details on the architecture for maintaining and updating the planning scene are outlined in the Planning Scene section below.

 Extensible Capabilities
move_group is structured to be easily extensible - individual capabilities like pick and place, kinematics, motion planning are actually implemented as separate plugins with a common base class. The plugins are configurable using ROS through a set of ROS yaml parameters and through the use of the ROS pluginlib library. Most users will not have to configure move_group plugins since they come automatically configured in the launch files generated by the MoveIt Setup Assistant.


`FollowJointTrajectoryAction` 是 ROS 中常用的消息类型，用于控制机械臂等多关节机器人执行轨迹动作。其消息格式由以下几个部分组成，主要包含 `Goal`、`Result` 和 `Feedback` 三个消息类型：

### 1. `Goal` 消息
该消息定义了机械臂的目标轨迹。包含关节名称和时间点的关节目标位置。

```plaintext
trajectory_msgs/JointTrajectory trajectory
duration path_tolerance
duration goal_tolerance
```

- **trajectory**: 包含目标轨迹的 `JointTrajectory` 消息，其中包括：
  - **joint_names**: 字符串数组，表示机械臂的关节名称。
  - **points**: `JointTrajectoryPoint` 数组，每个点定义了每个关节在特定时间的目标位置、速度、加速度等信息。

### 2. `Result` 消息
该消息表示轨迹执行的结果，通常包含一个返回码，表示动作是否成功完成。

```plaintext
int32 error_code
string error_string
```

- **error_code**: 整数类型，表示执行结果的状态码，例如 `0` 表示成功，负数表示失败。
- **error_string**: 字符串类型，描述错误的详细信息。

### 3. `Feedback` 消息
用于在轨迹执行过程中提供实时反馈。包含机械臂当前的关节状态。

```plaintext
trajectory_msgs/JointTrajectoryPoint actual
trajectory_msgs/JointTrajectoryPoint desired
trajectory_msgs/JointTrajectoryPoint error
```

- **actual**: 当前机械臂关节的位置、速度、加速度等信息。
- **desired**: 当前时间点的目标关节状态。
- **error**: 当前关节状态和目标状态之间的误差。

完整的 `FollowJointTrajectoryAction` 消息结构如下：

```plaintext
Header header
actionlib_msgs/GoalID goal_id
control_msgs/FollowJointTrajectoryGoal goal
control_msgs/FollowJointTrajectoryResult result
control_msgs/FollowJointTrajectoryFeedback feedback
```




